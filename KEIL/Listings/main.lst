C51 COMPILER V9.60.0.0   MAIN                                                              12/04/2025 18:45:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: C:\KeilC51\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\T5L51) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\main.lst) OBJECT(.\obj\main.obj)

line level    source

   1          /**
   2           * @file main.c
   3           * @brief Main application file for the DWIN T5L Demo Project.
   4           * @details This file contains the main entry point and the primary control loop.
   5           *          It handles initialization of CPU, timers, UART, and RTC.
   6           *          The main loop processes time updates, sends keep-alive messages via UART,
   7           *          handles received UART data to update display variables, and processes
   8           *          simulated button inputs from the display.
   9           */
  10          
  11          #include "sys.h"
  12          #include "uart.h"
  13          
  14          // Global variables
  15          /** @brief Counter variable incremented by button press. */
  16          u16 my_variable = 0;
  17          /** @brief Variable to store the button state read from DGUS VP. */
  18          u16 button_val = 0;
  19          /** @brief Timestamp for the last keep-alive message sent. */
  20          u16 last_keep_alive = 0;
  21          
  22          /**
  23           * @brief Main Entry Point
  24           * @details Initializes system peripherals and enters the infinite control loop.
  25           */
  26          void main(void)
  27          {
  28   1          // --- Initialization Phase ---
  29   1          INIT_CPU();     // Initialize CPU core registers and GPIO directions
  30   1          T0_Init();      // Initialize Timer 0 (System Tick)
  31   1          T1_Init();      // Initialize Timer 1 (RTC Tick)
  32   1          UART5_Init();   // Initialize UART5 for communication
  33   1          RTC_Init();     // Initialize Real Time Clock
  34   1          PORT_Init();    // Initialize Port IO specific configurations
  35   1      
  36   1          // Send startup message
  37   1          UART5_SendStr("Demo Started\r\n", 14);
  38   1      
  39   1          // Initialize the keep-alive timer
  40   1          last_keep_alive = Wait_Count;
  41   1      
  42   1          // --- Main Control Loop ---
  43   1          while(1)
  44   1          {
  45   2              // Update RTC and synchronize with Display VP if needed
  46   2              Time_Update();
  47   2      
  48   2              // --- Keep Alive Mechanism ---
  49   2              // Check if 5 seconds (5000 ticks) have passed since the last keep-alive
  50   2              if((u16)(Wait_Count - last_keep_alive) >= 5000)
  51   2              {
  52   3                  last_keep_alive = Wait_Count; // Reset timestamp
  53   3      
  54   3                  // --- ISPIS TACNOG VREMENA (NOVI KOD) ---
C51 COMPILER V9.60.0.0   MAIN                                                              12/04/2025 18:45:23 PAGE 2   

  55   3                  UART5_SendStr("Time: ", 6);
  56   3      
  57   3                  // Sat (H:M:S format)
  58   3                  UART5_Sendbyte((real_time.hour / 10) + '0');
  59   3                  UART5_Sendbyte((real_time.hour % 10) + '0');
  60   3                  UART5_Sendbyte(':');
  61   3      
  62   3                  // Minuta
  63   3                  UART5_Sendbyte((real_time.min / 10) + '0');
  64   3                  UART5_Sendbyte((real_time.min % 10) + '0');
  65   3                  UART5_Sendbyte(':');
  66   3      
  67   3                  // Sekunda
  68   3                  UART5_Sendbyte((real_time.sec / 10) + '0');
  69   3                  UART5_Sendbyte((real_time.sec % 10) + '0');
  70   3      
  71   3                  UART5_SendStr("\r\n", 2); // Novi red za vrijeme
  72   3                  // ----------------------------------------
  73   3              }
  74   2      
  75   2              // --- UART RX Handling ---
  76   2              // Check if there is new data in the UART receive buffer
  77   2              if(Rx_Head != Rx_Tail)
  78   2              {
  79   3                  // Read one byte from the circular buffer
  80   3                  u8 c = Rx_Buffer[Rx_Tail];
  81   3                  Rx_Tail = (Rx_Tail + 1) & 0x1F; // Increment tail with wrap-around
  82   3      
  83   3                  // Process Numeric Commands
  84   3                  // Check if the received character is a digit '0'-'9'
  85   3                  if(c >= '0' && c <= '9')
  86   3                  {
  87   4                      u16 val = (u16)(c - '0'); // Convert ASCII to integer
  88   4                      // Write the value to DGUS Variable Pointer (VP) address 0x1100
  89   4                      write_dgus_vp(0x2040, &val, 2);
  90   4      
  91   4                      // Echo back valid input
  92   4                      UART5_SendStr("written number: ", 16);
  93   4                      UART5_Sendbyte(c);
  94   4                      UART5_SendStr("\r\n", 2);
  95   4                  }
  96   3                  else
  97   3                  {
  98   4                      // Echo back invalid input
  99   4                      UART5_SendStr("out of limit\r\n", 14);
 100   4                  }
 101   3              }
 102   2      
 103   2              // --- Button Handling ---
 104   2              // Read the status of the button at VP address 0x1200.
 105   2              // The display is expected to write '1' to this address when the button is pressed.
 106   2              read_dgus_vp(0x1200, &button_val, 2);
 107   2      
 108   2              if(button_val == 1)
 109   2              {
 110   3                  my_variable++; // Increment the counter
 111   3      
 112   3                  // Send debug information via UART
 113   3                  UART5_SendStr("Variable updated [new value:", 28);
 114   3      
 115   3                  // Convert the 3-digit counter value to ASCII and send character by character
 116   3                  UART5_Sendbyte(((my_variable / 100) % 10) + '0'); // Hundreds digit
C51 COMPILER V9.60.0.0   MAIN                                                              12/04/2025 18:45:23 PAGE 3   

 117   3                  UART5_Sendbyte(((my_variable / 10) % 10) + '0');  // Tens digit
 118   3                  UART5_Sendbyte((my_variable % 10) + '0');         // Units digit
 119   3      
 120   3                  UART5_SendStr("]\r\n", 3); // End of line
 121   3      
 122   3                  
 123   3                  button_val = 0;
 124   3                  write_dgus_vp(0x1200, &button_val, 2);
 125   3                  // FORCE RESET LOOP: Keep writing 0 until the hardware acknowledges it
 126   3                  // This prevents the "machine gun" effect if a single write is missed.
 127   3      //            do
 128   3      //            {
 129   3      //                write_dgus_vp(0x1200, &button_val, 2);
 130   3      //                delay_ms(10); // Small wait for hardware
 131   3      //                read_dgus_vp(0x1200, &button_val, 2); // Verify
 132   3      //            } while(button_val == 1); // Retry if still 1
 133   3      
 134   3                  // Simple cooldown delay to prevent multiple triggers during a single press
 135   3      //            delay_ms(200);
 136   3              }
 137   2          }
 138   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    527    ----
   CONSTANT SIZE    =     90    ----
   XDATA SIZE       =      6       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
