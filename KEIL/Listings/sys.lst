C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SYS
OBJECT MODULE PLACED IN .\obj\sys.obj
COMPILER INVOKED BY: C:\KeilC51\C51\BIN\C51.EXE sys.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\T5L51) DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\sys.lst) OBJECT(.\obj\sys.obj)

line level    source

   1          /**
   2           * @file sys.c
   3           * @brief System Initialization and Utility Functions for DWIN T5L.
   4           * @details Implements core system setup, reliable DGUS memory access (Read/Write),
   5           * and Software RTC management.
   6           * Based on "Development-Guide-of-T5L-ASIC20220413".
   7           */
   8          
   9          #include "sys.h"
  10          #include "uart.h"
  11          #include "string.h"
  12          #include <intrins.h>
  13          
  14          // --- Lookup Tables for Calendar Calculation ---
  15          const u8 code table_week[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
  16          const u8 code mon_table[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
  17          const u8 code time_set_init[6] = {19,5,1,12,00,00};
  18          
  19          // --- System Global Variables ---
  20          /** @brief System tick counter, incremented every ms by Timer 0 ISR. Volatile for safe ISR access. */
  21          volatile u16 data Wait_Count = 0;          
  22          /** @brief Internal counter for the RTC tick, used to measure 1-second intervals. */
  23          static u16 data SysTick_RTC = 0;  
  24          /** @brief Countdown variable for the `delay_ms` function. */
  25          static u16 data SysTick = 0;      
  26          /** @brief Global structure holding the current real-time clock time. */
  27          rtc_time real_time;             
  28          /** @brief Flag set by the RTC ISR every second to signal the main loop to update the display. */
  29          volatile u16 Second_Updata_Flag = 0;       
  30          /** @brief Buffer to hold time values for display purposes. */
  31          u16 time_display[7] = {0};       
  32          
  33          /**
  34           * @brief Initialize CPU Core Registers
  35           * @details Sets up Interrupts, GPIO modes, UARTs, and Timers according to T5L specs.
  36           *          Includes robust defaults for Memory Pointers and Watchdog from factory demo.
  37           */
  38          void INIT_CPU(void)
  39          {
  40   1          EA = 0;           
  41   1          RS0 = 0;          
  42   1          RS1 = 0;
  43   1          
  44   1          // --- Clock & Memory Configuration (Factory Defaults) ---
  45   1          CKCON = 0x00;           // CPU Clock Control (Default)
  46   1          DPC = 0x00;             // Data Pointer Control (Default)
  47   1          PAGESEL = 0x01;         // Code Memory Page Select
  48   1          D_PAGESEL = 0x02;       // Data Memory Page Select (RAM 0x8000-0xFFFF)
  49   1      
  50   1          // --- Peripheral Multiplexing & Watchdog ---
  51   1          // MUX_SEL: Bit 6=UART2 En, Bit 5=UART3 En, Bit 1=WDT En, Bit 0=WDT Feed
  52   1          // Ensure Watchdog is OFF during init (Factory Default: 0x60 enables UART2/3)
  53   1          WDT_OFF(); 
  54   1      
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 2   

  55   1          PORTDRV = 0x01;   // Drive Strength +/- 8mA
  56   1          IEN0 = 0x00;      
  57   1          IEN1 = 0x00;
  58   1          IEN2 = 0x00;
  59   1          IP0 = 0x00;       
  60   1          IP1 = 0x00;
  61   1          
  62   1          // Initialize Ports to Input Mode (High Impedance/Weak Pull-up equivalent)
  63   1          P0 = 0xFF; P1 = 0xFF; P2 = 0xFF; P3 = 0xFF;
  64   1          
  65   1          // Configure Output Modes (1=Push-Pull) [cite: 1986]
  66   1          // Note: P0.4 (UART2 TX) set to Push-Pull (0x10). 
  67   1          // Specific project pins handled in PORT_Init().
  68   1          P0MDOUT = 0x10; 
  69   1          P1MDOUT = 0x00; 
  70   1          P2MDOUT = 0x00; 
  71   1          P3MDOUT = 0x00;
  72   1      
  73   1          // --- UART0 (Standard 8051 UART / UART2 in DWIN) Configuration ---
  74   1          // 115200 8N1 @ ~206MHz
  75   1          ADCON = 0x80;     
  76   1          SCON0 = 0x50;     
  77   1          SREL0H = 0x03;    
  78   1          SREL0L = 0xE4;    
  79   1          
  80   1          // --- UART3 Configuration (Optional/Factory Default) ---
  81   1          /*
  82   1          SCON1 = 0x50;
  83   1          SREL1H = 0x03; SREL1L = 0xC8;
  84   1          */
  85   1      
  86   1          // --- UART4 Configuration ---
  87   1          SCON2T = 0x80;    
  88   1          SCON2R = 0x80;    
  89   1          BODE2_DIV_H = 0x00; 
  90   1          BODE2_DIV_L = 0xE0;
  91   1      
  92   1          // --- UART5 Configuration ---
  93   1          // (See UART5_Init in uart.c for active configuration)
  94   1          
  95   1          // Timer Configuration
  96   1          TMOD = 0x11;      
  97   1          TH0 = 0x00; TL0 = 0x00; TR0 = 0x00; 
  98   1          TH1 = 0x00; TL1 = 0x00; TR1 = 0x00; 
  99   1          TCON = 0x05; // External Interrupt Edge Trigger (Factory Default)
 100   1          
 101   1          // Timer 2 Configuration (16-bit Auto-reload) [cite: 1925]
 102   1          T2CON = 0x70; 
 103   1          TH2 = 0x00; TL2 = 0x00; 
 104   1          TRL2H = 0xBC; TRL2L = 0xCD; // 1ms Reload Value
 105   1      }
 106          
 107          /**
 108           * @brief Initialize GPIO Port Directions.
 109           * @details Configures specific pins on P0, P1, and P2 as push-pull outputs.
 110           */
 111          void PORT_Init(void)
 112          {
 113   1          // Specific GPIO setup for the project
 114   1          P0MDOUT |= 0x02; // P0.1 (RS485 EN)
 115   1          
 116   1          // P1: Set to Push-Pull for LED/Counter demo
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 3   

 117   1          // We configure ALL P1 pins as Output to ensure the main loop counter works on all 8 bits.
 118   1          // Note: If AD1 is physically P1.1, reading it while driving it as Output might return the Output stat
             -e.
 119   1          // However, per user request, we treat them as separate/independent.
 120   1          P1MDOUT = 0xFF; 
 121   1          // P1 |= 0xEA; // Removed Input High-Z forcing
 122   1      
 123   1          // P2: Set P2.0 to Push-Pull for PWM (1kHz)
 124   1          P2MDOUT |= 0x03; // P2.0 (PWM) + P2.1 (Original)
 125   1      }
 126          
 127          /**
 128           * @brief Initialize the software Real-Time Clock.
 129           * @details Loads the `real_time` structure with a default compile-time date and time.
 130           */
 131          void RTC_Init(void)
 132          {
 133   1          // Load initial time values
 134   1          real_time.year = time_set_init[0];
 135   1          real_time.month = time_set_init[1];
 136   1          real_time.day = time_set_init[2];
 137   1          real_time.hour = time_set_init[3];
 138   1          real_time.min = time_set_init[4];
 139   1          real_time.sec = time_set_init[5];
 140   1      }
 141          
 142          /**
 143           * @brief Initialize Timer 0 for System Tick.
 144           * @details Configures Timer 0 to generate an interrupt every 1ms, which serves as the main system tick.
 145           */
 146          void T0_Init(void)
 147          {
 148   1          // System Tick Timer
 149   1          TMOD |= 0x01;         
 150   1          TH0 = T1MS >> 8;        
 151   1          TL0 = T1MS;           
 152   1          ET0 = 1;              
 153   1          EA = 1;               
 154   1          TR0 = 1;              
 155   1      }
 156          
 157          /**
 158           * @brief Initialize Timer 1 for RTC Tick.
 159           * @details Configures Timer 1 to generate a 1ms interrupt used for the software RTC counting.
 160           */
 161          void T1_Init(void)
 162          {
 163   1          // RTC Tick Timer
 164   1          TMOD |= 0x10;        
 165   1          TH1 = T1MS >> 8;        
 166   1          TL1 = T1MS;           
 167   1          ET1 = 1;              
 168   1          EA = 1;               
 169   1          TR1 = 1;              
 170   1      }
 171          
 172          /**
 173           * @brief Initialize Timer 2.
 174           * @details Configures Timer 2 for 500us interrupts to generate 1kHz PWM on P2.0.
 175           *          500us High + 500us Low = 1ms Period = 1kHz.
 176           */
 177          void T2_Init(void)
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 4   

 178          {
 179   1          T2CON = 0x70;       // 16-bit Auto-reload
 180   1          TH2 = 0x00;
 181   1          TL2 = 0x00;
 182   1          
 183   1          // Reload value for 500us (17.2032 MHz clock)
 184   1          // 65536 - (17203200 * 0.0005) = 56934 = 0xDE66
 185   1          TRL2H = 0xDE;       
 186   1          TRL2L = 0x66;       
 187   1          
 188   1          IEN0 |= 0x20;       // Enable Timer 2 Interrupt (ET2)
 189   1          TR2 = 1;            // Start Timer 2
 190   1      }
 191          
 192          /**
 193           * @brief Timer 2 Interrupt Service Routine.
 194           * @details Toggles P2.0 every 500us to create a 1kHz square wave (50% Duty Cycle).
 195           */
 196          void T2_ISR_PC(void) interrupt 5
 197          {
 198   1          TF2 = 0;        // Clear Overflow Flag (Hardware should do this in auto-reload, but safe to ensure)
 199   1          P2_0 = !P2_0;   // Toggle P2.0
 200   1      }
 201          
 202          // =============================================================================
 203          //  UNIVERSAL DGUS MEMORY ACCESS FUNCTIONS (OPTIMIZED)
 204          // =============================================================================
 205          
 206          /**
 207           * @brief Write data to DGUS Variable Pointer (VP) memory.
 208           * @details Optimized for DWIN T5L. Handles atomic 32-bit accesses, odd/even alignment,
 209           *          and supports multi-byte buffers.
 210           *          CRITICAL: Disables Global Interrupts (EA) during hardware access to prevent corruption.
 211           * @param addr 16-bit VP Address
 212           * @param vbuf Pointer to source buffer
 213           * @param len Length of data in bytes
 214           */
 215          void write_dgus_vp(u32 addr, void* vbuf, u16 len)
 216          {
 217   1          u8* buf = (u8*)vbuf;
 218   1          u32 OS_addr = addr >> 1;
 219   1          u8 is_odd = addr & 0x01;
 220   1          u8 mask;
 221   1          
 222   1          EA = 0; // Disable Interrupts for Atomic Access
 223   1      
 224   1          // 1. Set Initial Address
 225   1          ADR_H = (u8)(OS_addr >> 16);
 226   1          ADR_M = (u8)(OS_addr >> 8);
 227   1          ADR_L = (u8)OS_addr;
 228   1          ADR_INC = 0x01; // Enable Auto-Increment for bulk writes
 229   1      
 230   1          // 2. Handle Start Alignment (Odd Address Case)
 231   1          if(is_odd && len > 0)
 232   1          {
 233   2              // For Odd Address, we write to the Lower Half (DATA1/DATA0)
 234   2              // We temporarily Disable Auto-Increment to stay on the current word for this partial write
 235   2              ADR_INC = 0x00; 
 236   2              
 237   2              mask = 0x00;
 238   2              if(len > 0) { DATA1 = *buf++; mask |= 0x02; len--; }
 239   2              if(len > 0) { DATA0 = *buf++; mask |= 0x01; len--; }
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 5   

 240   2              
 241   2              if(mask)
 242   2              {
 243   3                  RAMMODE = 0x80 | mask; // Write Request + Byte Enables
 244   3                  APP_EN = 1; while(APP_EN); // Trigger & Wait
 245   3              }
 246   2      
 247   2              // Move to next OS Word (Even) manually since we disabled Auto-Inc
 248   2              // Or just re-enable Auto-Inc and dummy write? No, cleaner to just increment OS_addr.
 249   2              // Actually, simpler: Re-enable Auto-Inc for the main loop.
 250   2              // Since we wrote to the "Lower" half of the current address, the next write MUST be to the "Next"
             - address.
 251   2              // We need to manually increment the hardware address registers for the loop.
 252   2              // (OS_addr + 1)
 253   2              OS_addr++;
 254   2              ADR_H = (u8)(OS_addr >> 16);
 255   2              ADR_M = (u8)(OS_addr >> 8);
 256   2              ADR_L = (u8)OS_addr;
 257   2              ADR_INC = 0x01; 
 258   2          }
 259   1      
 260   1          // 3. Main Loop - Write Full Words (4 Bytes)
 261   1          while(len >= 4)
 262   1          {
 263   2              // Optimize: Use Full Write (0x8F) for speed
 264   2              RAMMODE = 0x8F; 
 265   2              DATA3 = *buf++;
 266   2              DATA2 = *buf++;
 267   2              DATA1 = *buf++;
 268   2              DATA0 = *buf++;
 269   2              APP_EN = 1; while(APP_EN);
 270   2              len -= 4;
 271   2          }
 272   1      
 273   1          // 4. Handle Remaining Bytes (1-3 bytes)
 274   1          if(len > 0)
 275   1          {
 276   2              // Auto-Increment is ON from loop. The hardware address is pointing to the NEXT word.
 277   2              // We just load data and mask correctly.
 278   2              mask = 0x00;
 279   2              if(len > 0) { DATA3 = *buf++; mask |= 0x08; }
 280   2              if(len > 1) { DATA2 = *buf++; mask |= 0x04; }
 281   2              if(len > 2) { DATA1 = *buf++; mask |= 0x02; }
 282   2              
 283   2              RAMMODE = 0x80 | mask;
 284   2              APP_EN = 1; while(APP_EN);
 285   2          }
 286   1      
 287   1          RAMMODE = 0x00; // Release Access
 288   1          EA = 1;         // Restore Interrupts
 289   1      }
 290          
 291          /**
 292           * @brief Read data from DGUS Variable Pointer (VP) memory.
 293           * @details Handles atomic 32-bit accesses, odd/even alignment, and supports multi-byte buffers.
 294           *          CRITICAL: Disables Global Interrupts (EA) during hardware access.
 295           * @param addr 16-bit VP Address
 296           * @param vbuf Pointer to destination buffer
 297           * @param len Length of data in bytes
 298           */
 299          void read_dgus_vp(u32 addr, void* vbuf, u16 len)
 300          {
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 6   

 301   1          u8* buf = (u8*)vbuf;
 302   1          u32 OS_addr = addr >> 1;
 303   1          u8 is_odd = addr & 0x01;
 304   1          
 305   1          EA = 0; // Disable Interrupts
 306   1      
 307   1          // 1. Set Initial Address
 308   1          ADR_H = (u8)(OS_addr >> 16);
 309   1          ADR_M = (u8)(OS_addr >> 8);
 310   1          ADR_L = (u8)OS_addr;
 311   1          ADR_INC = 0x01; // Enable Auto-Increment
 312   1      
 313   1          // 2. Handle Start Alignment (Odd Address)
 314   1          if(is_odd && len > 0)
 315   1          {
 316   2              ADR_INC = 0x00; // Disable Auto-Inc for partial read
 317   2              
 318   2              // Read Mode
 319   2              RAMMODE = 0xAF; 
 320   2              APP_EN = 1; while(APP_EN);
 321   2      
 322   2              if(len > 0) { *buf++ = DATA1; len--; }
 323   2              if(len > 0) { *buf++ = DATA0; len--; }
 324   2              
 325   2              // Move to next OS Word
 326   2              OS_addr++;
 327   2              ADR_H = (u8)(OS_addr >> 16);
 328   2              ADR_M = (u8)(OS_addr >> 8);
 329   2              ADR_L = (u8)OS_addr;
 330   2              ADR_INC = 0x01;
 331   2          }
 332   1      
 333   1          // 3. Main Loop - Read Full Words (4 Bytes)
 334   1          while(len >= 4)
 335   1          {
 336   2              RAMMODE = 0xAF;
 337   2              APP_EN = 1; while(APP_EN);
 338   2              
 339   2              *buf++ = DATA3;
 340   2              *buf++ = DATA2;
 341   2              *buf++ = DATA1;
 342   2              *buf++ = DATA0;
 343   2              len -= 4;
 344   2          }
 345   1      
 346   1          // 4. Handle Remaining Bytes
 347   1          if(len > 0)
 348   1          {
 349   2              RAMMODE = 0xAF;
 350   2              APP_EN = 1; while(APP_EN);
 351   2      
 352   2              if(len > 0) *buf++ = DATA3;
 353   2              if(len > 1) *buf++ = DATA2;
 354   2              if(len > 2) *buf++ = DATA1;
 355   2          }
 356   1      
 357   1          RAMMODE = 0x00;
 358   1          EA = 1; // Restore Interrupts
 359   1      }
 360          
 361          // --- Interrupt Service Routines & Logic ---
 362          
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 7   

 363          /**
 364           * @brief Timer 0 Interrupt Service Routine.
 365           * @details This ISR is triggered every 1ms. It reloads the timer, increments the main system
 366           *          `Wait_Count`, and decrements the `SysTick` counter for `delay_ms`.
 367           */
 368          void T0_ISR_PC(void) interrupt 1
 369          {
 370   1          TH0 = T1MS >> 8;    
 371   1          TL0 = T1MS;       
 372   1          Wait_Count++;   
 373   1          if(SysTick > 0) SysTick--;
 374   1      }
 375          
 376          /**
 377           * @brief Calculates the day of the week from a given date.
 378           * @param year The year (e.g., 24 for 2024).
 379           * @param month The month (1-12).
 380           * @param day The day of the month (1-31).
 381           * @return The day of the week, where 0 is Monday and 6 is Sunday.
 382           * @details This function implements a variation of Zeller's congruence to determine
 383           *          the day of the week. It uses a lookup table for month offsets.
 384           */
 385          u8 RTC_Get_Week(u8 year, u8 month, u8 day)
 386          {
 387   1          u16 temp;
 388   1          u16 year_real = (u16)year + 2000;
 389   1          u8 yearH = year_real / 100;
 390   1          u8 yearL = year_real % 100;
 391   1          
 392   1          if (yearH > 19) yearL += 100;
 393   1          
 394   1          temp = yearL + yearL / 4;
 395   1          temp = temp % 7;
 396   1          temp = temp + day + table_week[month - 1];
 397   1          
 398   1          if (yearL % 4 == 0 && month < 3) temp--;
 399   1          
 400   1          temp %= 7;
 401   1          if(temp == 0) return 6;
 402   1          else return temp - 1;
 403   1      }
 404          
 405          /**
 406           * @brief Updates RTC logic and synchronizes with DGUS Display.
 407           * @details Called from main loop. Uses non-overlapping addresses 
 408           * (0x2010, 0x2020, 0x2030) as confirmed working.
 409           */
 410          void Time_Update(void)
 411          {
 412   1          u16 hour_val, min_val, sec_val;
 413   1      
 414   1          MUX_SEL |= 0x01; // Feed Watchdog (Reset WDT) [cite: 1810]
 415   1          
 416   1          if(Second_Updata_Flag == 1)
 417   1          {
 418   2              real_time.week = RTC_Get_Week(real_time.year, real_time.month, real_time.day);
 419   2              
 420   2              // Prepare local variables (u16)
 421   2              hour_val = real_time.hour;
 422   2              min_val = real_time.min;
 423   2              sec_val = real_time.sec;
 424   2      
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 8   

 425   2              // --- WRITE TO DGUS VP ---
 426   2              // Using strict Even addresses spaced out to ensure no overlap.
 427   2              // Function write_dgus_vp will handle the 2-byte write safely.
 428   2              
 429   2              write_dgus_vp(0x2010, &hour_val, 2); 
 430   2              // No delay needed here with the correct 'while(APP_EN)' check in write_dgus_vp, 
 431   2              // but keeping small delay is safe for bus stability if desired.
 432   2              
 433   2              write_dgus_vp(0x2020, &min_val, 2);  
 434   2              
 435   2              write_dgus_vp(0x2030, &sec_val, 2);  
 436   2              
 437   2              Second_Updata_Flag = 0;
 438   2          }
 439   1      }
 440          
 441          /**
 442           * @brief Timer 1 Interrupt Service Routine.
 443           * @details This ISR is triggered every 1ms to drive the software RTC. It increments a counter
 444           *          and, upon reaching 1000ms (1 second), it updates the `real_time` structure and
 445           *          sets a flag for the main loop to update the display.
 446           */
 447          void T1_ISR_PC(void) interrupt 3
 448          {
 449   1          TH1 = T1MS >> 8;
 450   1          TL1 = T1MS;
 451   1          SysTick_RTC++;
 452   1          
 453   1          // 1 Second Heartbeat
 454   1          if(SysTick_RTC >= 1000)
 455   1          {
 456   2              SysTick_RTC = 0;
 457   2              real_time.sec++;
 458   2              if(real_time.sec > 59)
 459   2              {
 460   3                  real_time.sec = 0;
 461   3                  real_time.min++;
 462   3                  if(real_time.min > 59)
 463   3                  {
 464   4                      real_time.min = 0;
 465   4                      real_time.hour++;
 466   4                      if(real_time.hour > 23)
 467   4                      {
 468   5                          real_time.hour = 0;
 469   5                          real_time.day++;
 470   5                          // Basic Month/Day logic (simplified)
 471   5                          if(real_time.day > 28) { 
 472   6                              // Full calendar logic should go here if needed
 473   6                          } 
 474   5                      }
 475   4                  }
 476   3              }
 477   2              Second_Updata_Flag = 1; // Flag to update display in main loop
 478   2          }
 479   1      }
 480          
 481          /**
 482           * @brief Provides a blocking delay for a specified number of milliseconds.
 483           * @details This function uses a global counter `SysTick` which is decremented by the Timer 0 ISR.
 484           *          It is a "busy-wait" or "cooperative" delay, not a true sleep.
 485           * @param n The number of milliseconds to delay.
 486           */
C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 9   

 487          void delay_ms(u16 n)
 488          {
 489   1          SysTick = n;
 490   1          while(SysTick);
 491   1      }
 492          /**
 493           * @brief Upisuje cijeli 16.icl fajl (256KB) koristeci podatke sa RAM adrese 0x1000.
 494           * @details Ponavlja upis istog 32KB RAM buffera 8 puta na uzastopne Flash adrese.
 495           * Koristi 'delay_ms' da osigura da GUI jezgro stigne obraditi svaki blok.
 496           */
 497          void Test_Flash_Write_Full_16ICL(void)
 498          {
 499   1          u8 i;
 500   1          u8 cmd_buffer[12];
 501   1          
 502   1          // Proracun pocetnog bloka za ID 16:
 503   1          // Svaki ID = 256KB. Komanda piše 32KB.
 504   1          // 256 / 32 = 8 blokova po ID-u.
 505   1          // Pocetni blok = 16 * 8 = 128 (0x0080).
 506   1          u16 start_block_addr = 0x0080; 
 507   1      
 508   1          // Petlja od 0 do 7 (ukupno 8 blokova)
 509   1          for(i = 0; i < 8; i++)
 510   1          {
 511   2              // --- 1. Priprema komande za VP 0x00AA ---
 512   2      
 513   2              // D11:D10 - Enable (0x5A) & Mode (0x02 - Write 32KB)
 514   2              cmd_buffer[0] = 0x5A;
 515   2              cmd_buffer[1] = 0x02;
 516   2      
 517   2              // D9:D8 - Flash Block Address
 518   2              // U prvoj iteraciji 0x0080, u drugoj 0x0081, itd...
 519   2              cmd_buffer[2] = (u8)((start_block_addr + i) >> 8); 
 520   2              cmd_buffer[3] = (u8)(start_block_addr + i);        
 521   2      
 522   2              // D7:D6 - Source RAM Address
 523   2              // Uvijek uzimamo isti uzorak sa 0x1000 kako ste tražili
 524   2              cmd_buffer[4] = 0x10;
 525   2              cmd_buffer[5] = 0x00;
 526   2      
 527   2              // D5:D4 - Delay/Safety Wait (Parametar za GUI jezgro)
 528   2              // Kažemo GUI jezgru da priceka 100ms nakon upisa
 529   2              cmd_buffer[6] = 0x00;
 530   2              cmd_buffer[7] = 0x64; 
 531   2      
 532   2              // D3:D0 - Reserved (0x00)
 533   2              cmd_buffer[8] = 0x00;
 534   2              cmd_buffer[9] = 0x00;
 535   2              cmd_buffer[10] = 0x00;
 536   2              cmd_buffer[11] = 0x00;
 537   2      
 538   2              // --- 2. Slanje komande ---
 539   2              write_dgus_vp(0x00AA, cmd_buffer, 12);
 540   2      
 541   2              // --- 3. Obavezno cekanje ---
 542   2              // Moramo pauzirati OS jezgro da ne pregazimo komandu dok GUI jezgro piše u Flash.
 543   2              // 200ms je sigurna margina (32KB upis traje neko vrijeme).
 544   2              delay_ms(200); 
 545   2          }
 546   1      }
 547          

C51 COMPILER V9.60.0.0   SYS                                                               12/09/2025 18:18:17 PAGE 10  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2038    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =     24      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
