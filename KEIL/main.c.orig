/**
 * @file main.c
 * @brief Main application file for the DWIN T5L Demo Project.
 * @details This file contains the main entry point and the primary control loop.
 *          It handles initialization of CPU, timers, UART, and RTC.
 *          The main loop processes time updates, sends keep-alive messages via UART,
 *          handles received UART data to update display variables, and processes
 *          simulated button inputs from the display.
 */

#include "sys.h"
#include "uart.h"
#include "DWIN_GUI_VP.H"
#include <math.h> // Potrebno za log() funkciju
#include <stdio.h> // Za sprintf ako zatreba, ali radimo rucno radi brzine

extern u8 ADC_Read_Raw(u8 channel, u16* raw_value_ptr);
extern u8 LED_Set_Brightness_Now(u8 brightness);

// Global variables
/** @brief Counter variable incremented by button press. */
u16 my_variable = 0;
/** @brief Variable to store the button state read from DGUS VP. */
u16 button_val = 0;
/** @brief Timestamp for the last keep-alive message sent. */
u16 last_keep_alive = 0;
/** @brief Timestamp for P1 update. */
u16 last_p1_update = 0;
/** @brief Counter for Port 1. */
u8 p1_cnt = 0;

// ADC i Temperatura
u16 adc1_raw_val = 0;
float calculated_temp = 0.0f;
s16 temp_int_for_vp = 0; // Signed integer za VP (x100)

// Globalni buffer za touch podatke (8 bajtova = 4 worda)
u8 tp_dump[8];
u16 last_debug_timer = 0;

// Pomocna funkcija za slanje jednog bajta kao HEX (npr. 0xA5 ispisuje "A5 ")
void UART_Send_Hex(u8 b)
{
    u8 high = (b >> 4) & 0x0F;
    u8 low = b & 0x0F;
    
    if(high < 10) UART5_Sendbyte(high + '0'); 
    else UART5_Sendbyte(high - 10 + 'A');
    
    if(low < 10) UART5_Sendbyte(low + '0'); 
    else UART5_Sendbyte(low - 10 + 'A');
    
    UART5_Sendbyte(' '); // Razmak za citljivost
}
// --- Funkcija za kalkulaciju temperature ---
// Prilagodjena za C51 i T5L 16-bitni ADC
static float ROOM_GetTemperature(u16 adc_value)
{
    float temperature;
    float ntc_resistance;
    float adc_float = (float)adc_value;

    // Zastita od dijeljenja sa nulom (ako je ADC max, otpor je beskonacan/prekid)
    if(adc_value >= 65534) return -99.99f; // Greska senzor otvoren
    if(adc_value == 0) return 99.99f;      // Greska senzor kratak spoj

    // Kalkulacija otpora NTC-a
    // Formula prilagodjena za 16-bit ADC (65535 umjesto 4095)
    // Tvoja formula: Pullup * ((Max / (Max - Val)) - 1)
    // Ovo pretpostavlja da ADC mjeri napon na NTC-u (donji otpornik)
    ntc_resistance = AMBIENT_NTC_PULLUP * ((65535.0f / (65535.0f - adc_float)) - 1.0f);

    // Steinhart-Hart (Beta) jednacina
    // T = B / (B/To + ln(R/Ro))
    // 298.15f = 25 stepeni Celzijusa u Kelvinima
    // 273.15f = Konverzija Kelvin -> Celzijus
    temperature = (AMBIENT_NTC_B_VALUE * 298.15f) /
                  (AMBIENT_NTC_B_VALUE + (298.15f * log(ntc_resistance / AMBIENT_NTC_RREF)));

    temperature = temperature - 273.15f;

    return temperature;
}


void Update_GUI_RTC(void)
{
    u8 rtc_buffer[8];


    // Priprema podataka za VP 0x0010 (Sistemski RTC prikaz)
    // Format prema dokumentaciji (strana 50):
    // Y M D W H M S (7 bajtova + 1 dummy)

    rtc_buffer[0] = 0x19;   // Godina (npr. 23 za 2023)
    rtc_buffer[1] = 0x0B;  // Mjesec
    rtc_buffer[2] = 0x09;    // Dan
    rtc_buffer[3] = 0x02;   // Sedmica (0-6)
    rtc_buffer[4] = 0x10;   // Sat
    rtc_buffer[5] = 0x0D;    // Minuta
    rtc_buffer[6] = 0x00;    // Sekunda
    rtc_buffer[7] = 0x00;             // Nije definisano (dummy)

    // DIREKTAN upis na 0x0010
    // Ovo radi samo kad NEMA hardverskog RTC-a koji bi se takmicio sa vama
    write_dgus_vp(0x0010, rtc_buffer, 8); // Pišemo 4 word-a (8 bajtova)

}

// Funkcija za "Samouništenje" (Flash Overwrite Test)
void Self_Destruct_Test(void)
{
    // Staticka varijabla da osigura da se ovo desi samo jednom
    static bit is_triggered = 0;

    // Bufferi za komande
    u8 update_cmd[4];
    u8 reset_cmd[4];

    // Provjera tajmera: Da li je prošlo 20.000 ms (20 sekundi)?
    // Wait_Count se inkrementira u sys.c svakih 1ms
    if (!is_triggered && Wait_Count >= 20000)
    {
        is_triggered = 1; // Blokiraj ponovno izvršavanje

        // --- KORAK 1: Priprema komande za Update Koda (VP 0x06) ---
        // D3 = 0x5A: Enable / Trigger
        // D2 = 0xA5: Mode 0xA5 (Update User 8051 Code, 64KB block)
        // D1 = 0x10: Source Address High Byte (VP 0x1000)
        // D0 = 0x00: Source Address Low Byte
        update_cmd[0] = 0x5A;
        update_cmd[1] = 0xA5;
        update_cmd[2] = 0x10;
        update_cmd[3] = 0x00;

        // Opcionalno: Pošalji poruku na UART da znamo da pocinje kraj
        // UART5_SendStr("Bye Bye! Flashing garbage...\r\n", 28);

        // --- KORAK 2: Izvrši Flash Update ---
        // U ovom trenutku hardver pauzira CPU, briše Flash i upisuje
        // sadržaj sa adrese RAM 0x1000 u Code Flash.
        write_dgus_vp(0x0006, update_cmd, 4);

        // --- KORAK 3: Sigurnosno cekanje ---
        // Iako je CPU pauziran hardverski, dodajemo delay da budemo sigurni
        // da se ništa ne desi prije nego što je Flash stabilan.
        delay_ms(1000);

        // --- KORAK 4: Sistemski Reset (VP 0x04) ---
        // D3-D0 = 0x55, 0xAA, 0x5A, 0xA5
        reset_cmd[0] = 0x55;
        reset_cmd[1] = 0xAA;
        reset_cmd[2] = 0x5A;
        reset_cmd[3] = 0xA5;

        write_dgus_vp(0x0004, reset_cmd, 4);

        // Nakon ovoga, uredaj se resetuje.
        // Hardver kopira NOVI (vjerovatno neispravan) sadržaj iz Flasha u RAM.
        // Uredaj se više nece upaliti kako treba.
    }
}
// Strukura za 0x0084 komandu (2 Worda = 4 Bajta)
typedef struct {
    u16 enable_mode; // 0x5A01
    u16 pic_id;      // 0x0000 ili 0x0001
} pic_set_cmd;

void Test_Image_Switch(void)
{
    // Staticke varijable pamte stanje izmedu poziva funkcije
    static u16 last_img_time = 0; // Tajmer za sliku (5s)
    static u16 last_dnd_time = 0; // Tajmer za DND (400ms)
    static u16 last_hmd_time = 0; // Tajmer za HMD (900ms)

    static u16 current_image_id = 0; // Trenutna slika (0 ili 1)
    static u16 val_dnd = 0;          // Vrijednost za VP 0x1030
    static u16 val_hmd = 0;          // Vrijednost za VP 0x1040

    pic_set_cmd command;

    // --- 1. Logika za promjenu slike (Svakih 5000ms) ---
    // Koristimo Wait_Count koji se inkrementira u sys.c (T0_ISR)
    if((u16)(Wait_Count - last_img_time) >= 5000)
    {
        last_img_time = Wait_Count; // Resetuj tajmer za sliku

        // Prebaci ID slike: 0 -> 1 -> 0
        if(current_image_id == 0) current_image_id = 1;
        else current_image_id = 0;

        // Pošalji komandu za promjenu slike (VP 0x0084)
        command.enable_mode = 0x5A01;
        command.pic_id = current_image_id;
        write_dgus_vp(0x0084, &command, 4);
    }

    // --- 2. Logika za ikonice (Samo ako je slika 00 aktivna) ---
    if(current_image_id == 0)
    {
        // A) iconDND na VP 0x1030 (Svakih 400ms)
        if((u16)(Wait_Count - last_dnd_time) >= 400)
        {
            last_dnd_time = Wait_Count;

            // Toggle vrijednost 0 <-> 1
            if(val_dnd == 0) val_dnd = 1;
            else val_dnd = 0;

            // Upis na VP 0x1030 (DND Icon)
            write_dgus_vp(0x1030, &val_dnd, 2);
        }

        // B) iconHMD na VP 0x1040 (Svakih 900ms)
        if((u16)(Wait_Count - last_hmd_time) >= 900)
        {
            last_hmd_time = Wait_Count;

            // Toggle vrijednost 0 <-> 1
            if(val_hmd == 0) val_hmd = 1;
            else val_hmd = 0;

            // Upis na VP 0x1040 (HMD Icon)
            write_dgus_vp(0x1040, &val_hmd, 2);
        }
    }
}
/**
 * @brief Main Entry Point
 * @details Initializes system peripherals and enters the infinite control loop.
 */
void main(void)
{
    // --- Initialization Phase ---
    INIT_CPU();     // Initialize CPU core registers and GPIO directions
    T0_Init();      // Initialize Timer 0 (System Tick)
    T1_Init();      // Initialize Timer 1 (RTC Tick)
    T2_Init();      // Initialize Timer 2 (1kHz PWM on P2.0)
    UART5_Init();   // Initialize UART5 for communication
    RTC_Init();     // Initialize Real Time Clock
    PORT_Init();    // Initialize Port IO specific configurations

    // Send startup message
    UART5_SendStr("Demo Started\r\n", 14);

    // Update real RTC reg.
    Update_GUI_RTC();

    // Initialize the keep-alive timer
    last_keep_alive = Wait_Count;
    last_p1_update = Wait_Count;
    last_debug_timer = Wait_Count;
    // --- Main Control Loop ---
    while(1)
    {
        // Update RTC and synchronize with Display VP if needed
        Time_Update();

        // Try switching two background image
        Test_Image_Switch();


        //Self_Destruct_Test();
        // --- P1 Update (100ms) ---
        if((u16)(Wait_Count - last_p1_update) >= 100)
        {
            last_p1_update = Wait_Count;
            P1 = p1_cnt++;
            LED_Set_Brightness_Now(p1_cnt/3);

        }

        // --- Glavna petlja (Keep Alive + NTC mjerenje) ---
        if((u16)(Wait_Count - last_keep_alive) >= 2000) // Svake 2 sekunde
        {
            last_keep_alive = Wait_Count;

            // 1. Procitaj ADC (Kanal 1 - gdje je NTC spojen)
            if(ADC_Read_Raw(1, &adc1_raw_val) == 0)
            {
                u8 temp_buffer[2];

                // 2. Izracunaj temperaturu
                calculated_temp = ROOM_GetTemperature(adc1_raw_val);

                // 3. Konverzija u OBICNI Integer (BEZ MNOZENJA SA 100)
                // Ovo pretvara 33.80 u 33. To je ono sto zelis.
                temp_int_for_vp = (s16)calculated_temp;

                // 4. Rucno pakovanje (High/Low byte)
                temp_buffer[0] = (u8)((temp_int_for_vp >> 8) & 0xFF);
                temp_buffer[1] = (u8)(temp_int_for_vp & 0xFF);

                // Saljemo na VP 0x1020
                write_dgus_vp(0x1020, temp_buffer, 2);

                // 5. Posalji Debug info na UART5
                UART5_SendStr("NTC Raw: ", 9);
                // Ispis sirovog ADC
                UART5_Sendbyte((adc1_raw_val / 10000) + '0');
                UART5_Sendbyte(((adc1_raw_val % 10000) / 1000) + '0');
                UART5_Sendbyte(((adc1_raw_val % 1000) / 100) + '0');
                UART5_Sendbyte(((adc1_raw_val % 100) / 10) + '0');
                UART5_Sendbyte((adc1_raw_val % 10) + '0');

                UART5_SendStr(" | Temp: ", 9);

                // Jednostavan ispis float-a (XX.XX)
                if(calculated_temp < 0) {
                    UART5_Sendbyte('-');
                    calculated_temp = -calculated_temp;
                }

                // Cijeli dio
                UART5_Sendbyte(((u16)calculated_temp / 10) + '0');
                UART5_Sendbyte(((u16)calculated_temp % 10) + '0');
                UART5_Sendbyte('.');
                // Decimalni dio
                UART5_Sendbyte((((u16)(calculated_temp * 100)) % 100) / 10 + '0');
                UART5_Sendbyte((((u16)(calculated_temp * 100)) % 10) + '0');

                UART5_SendStr(" C\r\n", 4);
            }
            else
            {
                UART5_SendStr("ADC Error\r\n", 11);
            }
        }

        // --- UART RX Handling ---
        // Check if there is new data in the UART receive buffer
        if(Rx_Head != Rx_Tail)
        {
            // Read one byte from the circular buffer
            u8 c = Rx_Buffer[Rx_Tail];
            Rx_Tail = (Rx_Tail + 1) & 0x1F; // Increment tail with wrap-around

            // Process Numeric Commands
            // Check if the received character is a digit '0'-'9'
            if(c >= '0' && c <= '9')
            {
                u16 val = (u16)(c - '0'); // Convert ASCII to integer
                // Write the value to DGUS Variable Pointer (VP) address 0x1100
                write_dgus_vp(0x2040, &val, 2);

                // Echo back valid input
                UART5_SendStr("written number: ", 16);
                UART5_Sendbyte(c);
                UART5_SendStr("\r\n", 2);
            }
            else
            {
                // Echo back invalid input
                UART5_SendStr("out of limit\r\n", 14);
            }
        }

        // --- Button Handling ---
        // Read the status of the button at VP address 0x1200.
        // The display is expected to write '1' to this address when the button is pressed.
        read_dgus_vp(0x1200, &button_val, 2);

        if(button_val == 1)
        {
            my_variable++; // Increment the counter

            // Send debug information via UART
            UART5_SendStr("Variable updated [new value:", 28);

            // Convert the 3-digit counter value to ASCII and send character by character
            UART5_Sendbyte(((my_variable / 100) % 10) + '0'); // Hundreds digit
            UART5_Sendbyte(((my_variable / 10) % 10) + '0');  // Tens digit
            UART5_Sendbyte((my_variable % 10) + '0');         // Units digit
            UART5_SendStr("]\r\n", 3); // End of line
            button_val = 0;
            write_dgus_vp(0x1200, &button_val, 2);
        }
// Citaj svakih 50ms da ne zagušiš UART buffer, ali da bude "real-time"
        if((u16)(Wait_Count - last_debug_timer) >= 50)
        {
            last_debug_timer = Wait_Count;

            // Citaj 4 worda (8 bajtova) sa adrese 0x0016
            // 0x0016 je sistemska varijabla gdje T5L upisuje koordinate i status
            read_dgus_vp(0x0016, tp_dump, 4);

            // tp_dump[1] je obicno STATUS dodira (0x01 = Pritisnuto, 0x00 = Pusteno)
            // Ako je razlicito od 0, znaci da ekran registruje nešto
            if(tp_dump[1] != 0x00)
            {
                UART5_SendStr("TOUCH: ", 7);
                
                // Ispisi svih 8 bajtova redom
                // [0]=Header(5A) [1]=Status [2]=X_High [3]=X_Low [4]=Y_High [5]=Y_Low ...
                UART_Send_Hex(tp_dump[0]);
                UART_Send_Hex(tp_dump[1]);
                UART_Send_Hex(tp_dump[2]);
                UART_Send_Hex(tp_dump[3]);
                UART_Send_Hex(tp_dump[4]);
                UART_Send_Hex(tp_dump[5]);
                UART_Send_Hex(tp_dump[6]);
                UART_Send_Hex(tp_dump[7]);
                
                UART5_SendStr("\r\n", 2);
            }
        }
     }
}